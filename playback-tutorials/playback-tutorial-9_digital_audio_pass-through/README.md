# GStreamer 官方教程 playback-tutorial-9 的完整示例

原文地址: <https://gstreamer.freedesktop.org/documentation/tutorials/playback/digital-audio-pass-through.html?gi-language=c>

除了常见的模拟格式，高端音频系统通常也接受压缩或未压缩的数字形式数据。这样做很方便，因为音频信号可以从计算机传输到扬声器，以更抗干扰和噪声的形式传输，从而获得更高的质量。

这种连接通常通过 S/PDIF 线缆实现，可以是光纤（使用 TOSLINK 连接器）或同轴电缆（使用 RCA 连接器）。S/PDIF 也被称为 IEC 60958 类型 II（1998 年之前称为 IEC 958）。

在这个场景中，GStreamer 不需要执行音频解码；它可以直接输出编码数据，以透传模式运行，让外部音频系统执行解码。

## 音频接收器的内部工作原理

首先，必须在系统级别启用数字音频输出。实现这一功能的方法取决于操作系统，但通常需要进入音频控制面板并激活一个标有“数字音频输出”或类似字样的复选框。

每个平台的主要 GStreamer 音频接收器——Linux 的 Pulse Audio（ `pulsesink` ）、OS X 的 `osxaudiosink` 以及 Windows 的 Direct Sound（ `directsoundsink` ）——会检测到数字音频输出是否可用，并相应地更改它们的输入属性以接受编码数据。例如，这些元素通常接受 `audio/x-raw` 数据：当系统启用数字音频输出时，它们也可能接受 `audio/mpeg` 、 `audio/x-ac3` 、 `audio/x-eac3` 或 `audio/x-dts` 。

然后，当 `playbin` 构建解码管道时，它意识到音频输出端可以直接连接到编码数据（通常来自解复用器），因此不需要解码器。这个过程是自动的，不需要应用程序采取任何操作。

在 Linux 上，存在其他音频输出端，如 Alsa（ `alsasink` ），它们的工作方式不同（一个“数字设备”需要通过输出端的 `device` 属性手动选择）。然而，Pulse Audio 是 Linux 上常用的音频输出端。

## 数字格式的注意事项

当系统级别启用了数字音频输出时，GStreamer 音频输出端会自动暴露所有可能的数字音频能力，而不管 S/PDIF 线缆末端的实际音频解码器是否能够解码所有这些格式。这是因为没有机制来查询外部音频解码器支持哪些格式，而且实际上，在这个过程中线缆甚至可能被断开。

例如，在系统控制面板中启用数字音频输出后， `directsoundsink` 将自动暴露 `audio/x-ac3` 、 `audio/x-eac3` 和 `audio/x-dts` 帽，除了 `audio/x-raw` 。然而，某个特定的外部解码器可能只理解原始整数流，并会尝试以这种方式播放压缩数据（请放心，这对你的耳朵来说将是一种痛苦的经历）。

解决此问题需要用户干预，因为只有用户知道外部解码器支持哪些格式。

在某些系统上，最简单的解决方案是告知操作系统外部音频解码器可以接受的格式。这样，GStreamer 音频接收器将只提供这些格式。可接受的音频格式通常从操作系统的音频配置面板中选择，与启用数字音频输出的位置相同，但不幸的是，此选项并非所有音频驱动程序都可用。

另一种解决方案是使用自定义的 sinkbin（参见《播放教程 7：自定义 playbin sink》），该 `sinkbin` 包含一个 `capsfilter` 元素（参见《基础教程 14：实用元素》）和音频 `sink`。然后在 `capsfiler` 中设置外部解码器支持的 `caps`，以避免输出错误格式。这允许应用程序强制执行适当格式，而不是依赖用户正确配置系统。仍然需要用户干预，但无论音频驱动程序提供哪些选项，都可以使用。

请勿将 `autoaudiosink` 用作音频 sink，因为它目前仅支持原始音频，并将忽略任何压缩格式。
